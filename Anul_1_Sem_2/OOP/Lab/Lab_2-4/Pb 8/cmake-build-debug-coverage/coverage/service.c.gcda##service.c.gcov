        -:    0:Source:/mnt/d/Facultate/Anul 1 Sem 2/OOP/Lab/Lab 2-4/Pb 8/service.c
        -:    0:Graph:/mnt/d/Facultate/Anul 1 Sem 2/OOP/Lab/Lab 2-4/Pb 8/cmake-build-debug-coverage/CMakeFiles/Pb_8.dir/service.c.gcno
        -:    0:Data:/mnt/d/Facultate/Anul 1 Sem 2/OOP/Lab/Lab 2-4/Pb 8/cmake-build-debug-coverage/CMakeFiles/Pb_8.dir/service.c.gcda
        -:    0:Runs:1
        -:    1:#include <stdlib.h>
        -:    2:#include "list.h"
        -:    3:#include "produs.h"
        -:    4:#include "service.h"
        -:    5:#include "validare.h"
        -:    6:
function creeazaService called 2 returned 100% blocks executed 100%
        2:    7:Service *creeazaService() {
        2:    8:    Service *service = (Service *)malloc(sizeof(Service));
        2:    9:    service->produse = creeazaLista((Distruge) distrugeProdus, (Copiaza) copieProdus);
        2:    9-block  0
call    0 returned 2
        2:   10:    return service;
        -:   11:}
        -:   12:
function distrugeService called 2 returned 100% blocks executed 100%
        2:   13:void distrugeService(Service *service) {
        2:   14:    distrugeLista(service->produse);
        2:   14-block  0
call    0 returned 2
        2:   15:    free(service);
        2:   16:}
        -:   17:
function adaugaProdus called 4 returned 100% blocks executed 100%
        4:   18:int adaugaProdus(Service *service, Produs *produs) {
        4:   19:    if (validareProdus(produs) == 0)
        4:   19-block  0
call    0 returned 4
branch  1 taken 1 (fallthrough)
branch  2 taken 3
        1:   20:        return 0;
        1:   20-block  0
        -:   21:
        4:   22:    for (int i = 0; i < service->produse->lg; i++) {
        3:   22-block  0
        1:   22-block  1
        4:   22-block  2
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        2:   23:        Produs *produsExistent = (Produs *)service->produse->elems[i];
        2:   24:        if (produsExistent->id == produs->id) {
        2:   24-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   25:            produsExistent->cantitate += produs->cantitate;
        1:   26:            return 0;
        1:   26-block  0
        -:   27:        }
        -:   28:    }
        -:   29:
        2:   30:    add(service->produse, produs);
        2:   30-block  0
call    0 returned 2
        -:   31:
        2:   32:    return 1;
        -:   33:}
        -:   34:
function stergeProdus called 3 returned 100% blocks executed 100%
        3:   35:int stergeProdus(Service *service, int id) {
        3:   36:    if (validareId(id) == 0)
        3:   36-block  0
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1:   37:        return 0;
        1:   37-block  0
        -:   38:
        3:   39:    for (int i = 0; i < service->produse->lg; i++) {
        2:   39-block  0
        1:   39-block  1
        3:   39-block  2
branch  0 taken 2
branch  1 taken 1 (fallthrough)
        2:   40:        Produs *produs = (Produs *)service->produse->elems[i];
        2:   41:        if (produs->id == id) {
        2:   41-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   42:            service->produse->distruge(service->produse->elems[i]);
        1:   42-block  0
call    0 returned 1
        2:   43:            for (int j = i; j < service->produse->lg - 1; j++) {
        2:   43-block  0
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        1:   44:                service->produse->elems[j] = service->produse->elems[j + 1];
        1:   44-block  0
        -:   45:            }
        1:   46:            service->produse->lg--;
        1:   47:            return 1;
        1:   47-block  0
        -:   48:        }
        -:   49:    }
        -:   50:
        1:   51:    return 0;
        1:   51-block  0
        -:   52:}
        -:   53:
function modificaPret called 4 returned 100% blocks executed 100%
        4:   54:int modificaPret(Service *service, int id, float pret) {
        4:   55:    if (validareId(id) == 0 || validarePret(pret) == 0)
        4:   55-block  0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
        4:   55-block  1
call    3 returned 4
branch  4 taken 1 (fallthrough)
branch  5 taken 3
        1:   56:        return 0;
        1:   56-block  0
        -:   57:
        5:   58:    for (int i = 0; i < service->produse->lg; i++) {
        3:   58-block  0
        2:   58-block  1
        5:   58-block  2
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3:   59:        Produs *produs = (Produs *)service->produse->elems[i];
        3:   60:        if (produs->id == id) {
        3:   60-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   61:            produs->pret = pret;
        1:   62:            return 1;
        1:   62-block  0
        -:   63:        }
        -:   64:    }
        -:   65:
        2:   66:    return 0;
        2:   66-block  0
        -:   67:}
        -:   68:
function modificaCantitate called 4 returned 100% blocks executed 100%
        4:   69:int modificaCantitate(Service *service, int id, int cantitate) {
        4:   70:    if (validareId(id) == 0 || validareCantitate(cantitate) == 0)
        4:   70-block  0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
        4:   70-block  1
call    3 returned 4
branch  4 taken 1 (fallthrough)
branch  5 taken 3
        1:   71:        return 0;
        1:   71-block  0
        -:   72:
        5:   73:    for (int i = 0; i < service->produse->lg; i++) {
        3:   73-block  0
        2:   73-block  1
        5:   73-block  2
branch  0 taken 3
branch  1 taken 2 (fallthrough)
        3:   74:        Produs *produs = (Produs *)service->produse->elems[i];
        3:   75:        if (produs->id == id) {
        3:   75-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:   76:            produs->cantitate = cantitate;
        1:   77:            return 1;
        1:   77-block  0
        -:   78:        }
        -:   79:    }
        -:   80:
        2:   81:    return 0;
        2:   81-block  0
        -:   82:}
        -:   83:
function ordoneazaProduseDupaPret called 2 returned 100% blocks executed 100%
        2:   84:List *ordoneazaProduseDupaPret(Service *service, int mod) {
        2:   85:    List *listaNoua = copiazaLista(service->produse);
        2:   85-block  0
call    0 returned 2
        -:   86:
        4:   87:    for (int i = 0; i < listaNoua->lg - 1; i++) {
        2:   87-block  0
        4:   87-block  1
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        4:   88:        for (int j = i + 1; j < listaNoua->lg; j++) {
        2:   88-block  0
        2:   88-block  1
        4:   88-block  2
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        2:   89:            Produs *produs1 = (Produs *)listaNoua->elems[i];
        2:   90:            Produs *produs2 = (Produs *)listaNoua->elems[j];
        2:   91:            if ((mod == 0 && produs1->pret > produs2->pret) ||
        2:   91-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:   91-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        1:   91-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:   92:                (mod == 1 && produs1->pret < produs2->pret)) {
        1:   92-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1:   93:                listaNoua->elems[i] = produs2;
        1:   94:                listaNoua->elems[j] = produs1;
        1:   94-block  0
        -:   95:            }
        -:   96:        }
        -:   97:    }
        -:   98:
        2:   99:    return listaNoua;
        2:   99-block  0
        -:  100:}
        -:  101:
function ordoneazaProduseDupaCantitate called 2 returned 100% blocks executed 100%
        2:  102:List *ordoneazaProduseDupaCantitate(Service *service, int mod) {
        2:  103:    List *listaNoua = copiazaLista(service->produse);
        2:  103-block  0
call    0 returned 2
        -:  104:
        4:  105:    for (int i = 0; i < listaNoua->lg - 1; i++) {
        2:  105-block  0
        4:  105-block  1
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        4:  106:        for (int j = i + 1; j < listaNoua->lg; j++) {
        2:  106-block  0
        2:  106-block  1
        4:  106-block  2
branch  0 taken 2
branch  1 taken 2 (fallthrough)
        2:  107:            Produs *produs1 = (Produs *)listaNoua->elems[i];
        2:  108:            Produs *produs2 = (Produs *)listaNoua->elems[j];
        2:  109:            if ((mod == 0 && produs1->cantitate > produs2->cantitate) ||
        2:  109-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  109-block  1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        1:  109-block  2
branch  4 taken 1 (fallthrough)
branch  5 taken 0
        1:  110:                (mod == 1 && produs1->cantitate < produs2->cantitate)) {
        1:  110-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        1:  111:                listaNoua->elems[i] = produs2;
        1:  112:                listaNoua->elems[j] = produs1;
        1:  112-block  0
        -:  113:            }
        -:  114:        }
        -:  115:    }
        -:  116:
        2:  117:    return listaNoua;
        2:  117-block  0
        -:  118:}
        -:  119:
function filtreazaProduseDupaCantitate called 2 returned 100% blocks executed 100%
        2:  120:List *filtreazaProduseDupaCantitate(Service *service, int cantitate) {
        2:  121:    List *listaNoua = creeazaLista((Distruge) distrugeProdus, (Copiaza) copieProdus);
        2:  121-block  0
call    0 returned 2
        -:  122:
        6:  123:    for (int i = 0; i < service->produse->lg; i++) {
        4:  123-block  0
        6:  123-block  1
branch  0 taken 4
branch  1 taken 2 (fallthrough)
        4:  124:        Produs *produs = (Produs *)service->produse->elems[i];
        4:  125:        if (produs->cantitate == cantitate) {
        4:  125-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 3
        1:  126:            add(listaNoua, copieProdus(produs));
        1:  126-block  0
call    0 returned 1
call    1 returned 1
        -:  127:        }
        -:  128:    }
        -:  129:
        2:  130:    return listaNoua;
        2:  130-block  0
        -:  131:}
